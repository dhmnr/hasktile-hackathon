{-# LANGUAGE OverloadedStrings #-}

module TileIR.GEMM
  ( generateGEMMKernel
  ) where

import qualified Data.Text as T

-- | Generate GEMM kernel for square NxN @ NxN multiplication
-- Each tile block computes 64x64 output tiles of C
-- This implements: C = A @ B
-- Parameters: matrix_size (N), tile_size (64)
generateGEMMKernel :: Int -> Int -> T.Text
generateGEMMKernel matrix_size tile_size = T.unlines
  [ "cuda_tile.module @gemm_module {"
  , "  entry @gemm_kernel("
  , "    %a_ptr_base_scalar: tile<ptr<f32>>,"
  , "    %b_ptr_base_scalar: tile<ptr<f32>>,"
  , "    %c_ptr_base_scalar: tile<ptr<f32>>"
  , "  ) {"
  , "    // Get block indices"
  , "    %block_x_index, %block_y_index, %block_z_index = get_tile_block_id : tile<i32>"
  , ""
  , "    // Tile dimensions"
  , "    %tile_size = constant <i32: " <> T.pack (show tile_size) <> "> : tile<i32>"
  , "    %stride_scalar = constant <i32: " <> T.pack (show matrix_size) <> "> : tile<i32>"
  , "    %k_tiles = constant <i32: " <> T.pack (show (matrix_size `div` tile_size)) <> "> : tile<i32>"
  , ""
  , "    // Broadcast stride to 2D for matrix operations"
  , "    %stride_1d = reshape %stride_scalar : tile<i32> -> tile<1xi32>"
  , "    %stride_1d_bcast = broadcast %stride_1d : tile<1xi32> -> tile<64xi32>"
  , "    %stride_factor = reshape %stride_1d_bcast : tile<64xi32> -> tile<64x1xi32>"
  , "    %stride_factor_2d = broadcast %stride_factor : tile<64x1xi32> -> tile<64x64xi32>"
  , ""
  , "    // Initialize accumulator to zero"
  , "    %init_accum = constant <f32: 0.000000e+00> : tile<64x64xf32>"
  , ""
  , "    // Compute A tile pointer (row-major)"
  , "    // A starts at: block_x_index * 64"
  , "    %a_row_start = muli %block_x_index, %tile_size : tile<i32>"
  , ""
  , "    // Compute B tile pointer (row-major)"
  , "    // B starts at: block_y_index * 64"
  , "    %b_col_start = muli %block_y_index, %tile_size : tile<i32>"
  , ""
  , "    // Create iota for tile indexing"
  , "    %tile_range = iota : tile<64xi32>"
  , ""
  , "    // Setup A offset matrix (64x64)"
  , "    // Row indices: block_x_index * 64 + [0..63]"
  , "    %a_row_base_1d = reshape %a_row_start : tile<i32> -> tile<1xi32>"
  , "    %a_row_base_bcast = broadcast %a_row_base_1d : tile<1xi32> -> tile<64xi32>"
  , "    %a_row_indices = addi %a_row_base_bcast, %tile_range : tile<64xi32>"
  , ""
  , "    // Broadcast row indices to matrix (each column identical)"
  , "    %a_row_matrix = reshape %a_row_indices : tile<64xi32> -> tile<64x1xi32>"
  , "    %a_row_broadcast = broadcast %a_row_matrix : tile<64x1xi32> -> tile<64x64xi32>"
  , "    %a_row_offsets = muli %a_row_broadcast, %stride_factor_2d : tile<64x64xi32>"
  , ""
  , "    // Column indices start at 0 (will be updated in loop)"
  , "    %a_col_matrix = reshape %tile_range : tile<64xi32> -> tile<1x64xi32>"
  , "    %a_col_broadcast = broadcast %a_col_matrix : tile<1x64xi32> -> tile<64x64xi32>"
  , "    %a_init_offsets = addi %a_row_offsets, %a_col_broadcast : tile<64x64xi32>"
  , ""
  , "    // Setup B offset matrix (64x64)"
  , "    // Row indices start at 0 (will be updated in loop)"
  , "    %b_row_matrix = reshape %tile_range : tile<64xi32> -> tile<64x1xi32>"
  , "    %b_row_broadcast = broadcast %b_row_matrix : tile<64x1xi32> -> tile<64x64xi32>"
  , "    %b_row_offsets = muli %b_row_broadcast, %stride_factor_2d : tile<64x64xi32>"
  , ""
  , "    // Column indices: block_y_index * 64 + [0..63]"
  , "    %b_col_base_1d = reshape %b_col_start : tile<i32> -> tile<1xi32>"
  , "    %b_col_base_bcast = broadcast %b_col_base_1d : tile<1xi32> -> tile<64xi32>"
  , "    %b_col_indices = addi %b_col_base_bcast, %tile_range : tile<64xi32>"
  , "    %b_col_matrix = reshape %b_col_indices : tile<64xi32> -> tile<1x64xi32>"
  , "    %b_col_broadcast = broadcast %b_col_matrix : tile<1x64xi32> -> tile<64x64xi32>"
  , "    %b_init_offsets = addi %b_row_offsets, %b_col_broadcast : tile<64x64xi32>"
  , ""
  , "    // Convert base pointers to tiles"
  , "    %a_ptr_base_tile = reshape %a_ptr_base_scalar : tile<ptr<f32>> -> tile<1x1xptr<f32>>"
  , "    %a_ptr_base = broadcast %a_ptr_base_tile : tile<1x1xptr<f32>> -> tile<64x64xptr<f32>>"
  , "    %a_tile_ptr = offset %a_ptr_base, %a_init_offsets : tile<64x64xptr<f32>>, tile<64x64xi32> -> tile<64x64xptr<f32>>"
  , ""
  , "    %b_ptr_base_tile = reshape %b_ptr_base_scalar : tile<ptr<f32>> -> tile<1x1xptr<f32>>"
  , "    %b_ptr_base = broadcast %b_ptr_base_tile : tile<1x1xptr<f32>> -> tile<64x64xptr<f32>>"
  , "    %b_tile_ptr = offset %b_ptr_base, %b_init_offsets : tile<64x64xptr<f32>>, tile<64x64xi32> -> tile<64x64xptr<f32>>"
  , ""
  , "    // K-loop: iterate over 64 tiles in k-dimension"
  , "    %k_start = constant <i32: 0> : tile<i32>"
  , "    %k_step = constant <i32: 1> : tile<i32>"
  , "    %stride_k = constant <i32: 64> : tile<64x64xi32>"
  , ""
  , "    %C_tile, %a_ptr_final, %b_ptr_final = for %k in (%k_start to %k_tiles, step %k_step) : tile<i32>"
  , "      iter_values("
  , "        %acc_prev = %init_accum,"
  , "        %a_tile_ptr_prev = %a_tile_ptr,"
  , "        %b_tile_ptr_prev = %b_tile_ptr"
  , "      ) -> (tile<64x64xf32>, tile<64x64xptr<f32>>, tile<64x64xptr<f32>>)"
  , "    {"
  , "      // Load A and B tiles"
  , "      %A_tile, %token_a = load_ptr_tko weak %a_tile_ptr_prev : tile<64x64xptr<f32>> -> tile<64x64xf32>, token"
  , "      %B_tile, %token_b = load_ptr_tko weak %b_tile_ptr_prev : tile<64x64xptr<f32>> -> tile<64x64xf32>, token"
  , ""
  , "      // Matrix multiply-accumulate: C += A @ B"
  , "      %C_tile_acc = mmaf %A_tile, %B_tile, %acc_prev : tile<64x64xf32>, tile<64x64xf32>, tile<64x64xf32>"
  , ""
  , "      // Advance pointers for next k-tile"
  , "      // A advances by tile_size columns (right)"
  , "      %a_tile_ptr_next = offset %a_tile_ptr_prev, %stride_k : tile<64x64xptr<f32>>, tile<64x64xi32> -> tile<64x64xptr<f32>>"
  , ""
  , "      // B advances by tile_size rows down (stride * tile_size)"
  , "      %b_stride_full = constant <i32: " <> T.pack (show (matrix_size * tile_size)) <> "> : tile<64x64xi32>"
  , "      %b_tile_ptr_next = offset %b_tile_ptr_prev, %b_stride_full : tile<64x64xptr<f32>>, tile<64x64xi32> -> tile<64x64xptr<f32>>"
  , ""
  , "      continue %C_tile_acc, %a_tile_ptr_next, %b_tile_ptr_next : tile<64x64xf32>, tile<64x64xptr<f32>>, tile<64x64xptr<f32>>"
  , "    }"
  , ""
  , "    // Setup C offset matrix"
  , "    %c_row_start = muli %block_x_index, %tile_size : tile<i32>"
  , "    %c_row_base_1d = reshape %c_row_start : tile<i32> -> tile<1xi32>"
  , "    %c_row_base_bcast = broadcast %c_row_base_1d : tile<1xi32> -> tile<64xi32>"
  , "    %c_row_indices = addi %c_row_base_bcast, %tile_range : tile<64xi32>"
  , "    %c_row_matrix = reshape %c_row_indices : tile<64xi32> -> tile<64x1xi32>"
  , "    %c_row_broadcast = broadcast %c_row_matrix : tile<64x1xi32> -> tile<64x64xi32>"
  , "    %c_row_offsets = muli %c_row_broadcast, %stride_factor_2d : tile<64x64xi32>"
  , ""
  , "    %c_col_start = muli %block_y_index, %tile_size : tile<i32>"
  , "    %c_col_base_1d = reshape %c_col_start : tile<i32> -> tile<1xi32>"
  , "    %c_col_base_bcast = broadcast %c_col_base_1d : tile<1xi32> -> tile<64xi32>"
  , "    %c_col_indices = addi %c_col_base_bcast, %tile_range : tile<64xi32>"
  , "    %c_col_matrix = reshape %c_col_indices : tile<64xi32> -> tile<1x64xi32>"
  , "    %c_col_broadcast = broadcast %c_col_matrix : tile<1x64xi32> -> tile<64x64xi32>"
  , ""
  , "    %c_offsets = addi %c_row_offsets, %c_col_broadcast : tile<64x64xi32>"
  , ""
  , "    // Convert C base pointer and offset"
  , "    %c_ptr_base_tile = reshape %c_ptr_base_scalar : tile<ptr<f32>> -> tile<1x1xptr<f32>>"
  , "    %c_ptr_base = broadcast %c_ptr_base_tile : tile<1x1xptr<f32>> -> tile<64x64xptr<f32>>"
  , "    %c_tile_ptr = offset %c_ptr_base, %c_offsets : tile<64x64xptr<f32>>, tile<64x64xi32> -> tile<64x64xptr<f32>>"
  , ""
  , "    // Store result"
  , "    store_ptr_tko weak %c_tile_ptr, %C_tile : tile<64x64xptr<f32>>, tile<64x64xf32> -> token"
  , ""
  , "    return"
  , "  }"
  , "}"
  ]
